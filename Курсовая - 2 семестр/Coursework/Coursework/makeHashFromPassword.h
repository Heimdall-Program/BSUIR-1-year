#pragma once
//128-битный хеш.
#include <cstdint>
#include <memory.h>
#include <iostream>
#include <vector>
#include <string>
#include <ctime>

/*Определяет порядок байт на исполняемом компьютере.Сделаем это следующим образом : создадим int, которому присвоим ему значение 1, и посмотрим на левый байт этого числа.Если он равен 1, то определим порядок байт как little - endian, если 0, то big - endian.
Далее если на исполняемом компьютере little - endian, то шаг выполнен, если big - endian, то вручную сделаем реверс - байт.
Добавление к последовательности её первоначальную длину в битах в 64-битном формате в порядке байт little-endian.
 длина последовательности будет увеличиваться, алгоритм требует что бы мы помнили первоначальный размер
*/
bool endian();

//Добавить к последовательности единичный бит, затем добавлять нулевые биты, пока длина последовательности не станет сравнима с 448 по модулю 512 в битах.
//Поскольку мы работаем с байтами, то нам нужно добавить единичный байт 0x80 (1000 0000), и добавлять нулевые байты(0x00), пока длина последовательности не станет сравнима с 56 по модулю 64 в байтах.Создадим указатель end, который всегда будет ссылаться на байт, находящийся сразу за последним байтом нашей последовательности.

void append_padding_bits();

//Вызывает endian
//Поскольку saved_length содержит длину входных данных в байтах, а нам нужно записать в длину в битах, то создадим новую переменную,
//которой присвоим значение saved_length * 8, и с помощью функции Memory Copy скопируем её в конец последовательности.
void append_length();


//подготовка закончена
void init_buffer();

//Текущая последовательность разбивается на блоки по 64 байта (512 бит), 
//и в каждом блоке происходят раунды, которые перемешивают и сжимают информацию.
uint32_t rotate_left(uint32_t, uint32_t);

uint32_t F(uint32_t, uint32_t, uint32_t);
uint32_t G(uint32_t, uint32_t, uint32_t);
uint32_t H(uint32_t, uint32_t, uint32_t);
uint32_t I(uint32_t, uint32_t, uint32_t);


//Каждая из этих функций принимает на вход три 32 - битных переменные, и возвращает тоже 32 - битную переменную.
//Они нужны для перемешивания информации и повышения криптостойкости.
void round(uint32_t&, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t(*function)(uint32_t, uint32_t, uint32_t));

void process_block(uint8_t*);
void process();
//функция, которая бежит по последовательности и для каждого блока вызывает метод, обрабатывающий сам 64-байтный блок.
std::vector<uint8_t> finish();
std::vector<uint8_t> MD5(void*, uint64_t); //обобщённый указатель, может указывать на любой тип данных
//Переводим хеш из vector в string.
std::string md5hash_to_string(std::vector<uint8_t>);


std::string doHashNow(string);